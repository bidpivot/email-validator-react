# EmailValidator Notes

# CSS


// DONE // fix "undefined" issue
// fix container issue that causes horizontal scroll mobile
put in some type of logo
// DONE // put in a footer
fix footer at the bottom of the screen
make the textArea blink when someone clicks on it
figure out why :focus still isn't working
figure out a way to display the number of results
start to use the CSS to build out a CSS template kit for future projects



# chatGPT's recommended refactoring

Your code looks generally well-structured, but you can make it even more organized and maintainable by breaking it down into smaller components and using React hooks more effectively. Here are some refactoring suggestions:

1. **Create Separate Components:** Divide your code into smaller components, each responsible for its own part of the UI. This makes your code easier to read and maintain.

```javascript
// Example components:
import Form from "./components/Form";
import Result from "./components/Result";

export default function App() {
  // ... Your state and functions ...

  return (
    <>
      <header>{<SubHeader />}</header>
      <main>
        <div className="container">
          <div className="app-container">
            <div className="col-left">
              <Form
                first={first}
                last={last}
                domain={domain}
                nick={nick}
                middle={middle}
                tld={tld}
                expanded={expanded}
                onFormSubmit={handleFormSubmit}
                onExpandToggle={handleExpandButton}
                onInputChange={(field, value) => handleInputChange(field, value)}
              />
            </div>
            <div className="col-right">
              <Result emails={emails} />
            </div>
          </div>
        </div>
      </main>
    </>
  );
}
```

2. **Use a Single State Object:** Instead of multiple state variables for first, last, domain, etc., you can maintain a single state object. This can simplify your code and make it more scalable.

```javascript
const [formData, setFormData] = useState({
  first: "",
  last: "",
  domain: "",
  nick: "",
  middle: "",
  tld: ".com",
});
```

3. **Passing Functions:** Instead of separate `setX` functions for each field, create a single function to handle input changes.

```javascript
function handleInputChange(field, value) {
  setFormData({
    ...formData,
    [field]: value,
  });
}
```

4. **Use Memoization:** You can memoize the `parameterObject` to ensure that it's recalculated only when necessary.

```javascript
const parameterObject = useMemo(() => {
  const { first, last, domain, tld, middle, nick } = formData;
  return {
    first: first.toLowerCase(),
    last: last.toLowerCase(),
    domain: domain.toLowerCase(),
    tld: tld.toLowerCase(),
    middle: middle.toLowerCase(),
    nick: nick.toLowerCase(),
  };
}, [formData]);
```

5. **Componentize Your Form:** Create a separate component for your form inputs to keep your code organized.

```javascript
function Form({
  first,
  last,
  domain,
  nick,
  middle,
  tld,
  expanded,
  onFormSubmit,
  onInputChange,
  onExpandToggle,
}) {
  return (
    <form onSubmit={onFormSubmit}>
      {/* Input fields */}
      {/* Expand button */}
    </form>
  );
}
```

By organizing your code in this manner, it becomes more modular and easier to manage as your application grows. Components become self-contained, and state management is more centralized, making it easier to debug and add features.
